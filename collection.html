<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>集合 - C# 面试笔记</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C# 面试笔记</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="content-wrap">
                            <h1 id="集合"><a class="header" href="#集合">集合</a></h1>
<h2 id="ilist-接口与list的区别是什么"><a class="header" href="#ilist-接口与list的区别是什么">IList 接口与List的区别是什么?</a></h2>
<p>IList 泛型接口是 Icollection 接口的子代，并且是所有非泛型列表的基接口。 Ilist 实现有三种类别：只读、固定大小、可变大小。 无法修改只读 Ilist。 固定大小的 Ilist 不允许添加或移除元素，但允许修改现有元素。 可变大小的 Ilist 允许添加、移除和修改元素。</p>
<p>IList 是个接口，定义了一些操作方法这些方法要你自己去实现，当你只想使用接口的方法时，这种方式比较好。他不获取实现这个接口的类的其他方法和字段，有效的节省空间。</p>
<p>List 是个类型 已经实现了IList 定义的那些方法。</p>
<pre><code class="language-csharp">List List1 = new List ();
</code></pre>
<p>是想创建一个List，而且需要使用到List的功能，进行相关操作。</p>
<pre><code class="language-csharp">IList IList1 = new List ();
</code></pre>
<p>而只是想创建一个基于接口IList的对象的实例，只是这个接口是由List实现的。所以它只是希望使用到IList接口规定的功能而已。</p>
<h2 id="如何把一个array复制到arraylist里"><a class="header" href="#如何把一个array复制到arraylist里">如何把一个array复制到arrayList里?</a></h2>
<pre><code class="language-csharp">foreach( object arr in array)
{
    arrayist.Add(arr);
}
</code></pre>
<h2 id="数组和-list-和-arraylist-的区别"><a class="header" href="#数组和-list-和-arraylist-的区别">数组和 list 和 arraylist 的区别?</a></h2>
<p>**数组：**是存储同类型数据列表，数组在内存中是连续存储的。优点:存储、修改、读取速度快。缺点:初始化需要指定长度，无法扩展，插入数据麻烦</p>
<p>**ArrayList:**ArrayList是.Net Framework提供的用于数据存储和检索的专用类，它是命名空间System.Collections下的一部分。它的大小是按照其中存储的数据来动态扩充与收缩的。优点:可扩展，无指定长度，可插入删除</p>
<p>缺点:因存储不同类型，执行装箱拆箱操作，读取、存储速度慢。</p>
<p>**List:**在数组和ArrayList基础上优化，存储通用类型数据列表。优点:可扩展示，初始化无需指定长度，可插入指定位置数据</p>
<h2 id="list-set-map是否继承自collection接口"><a class="header" href="#list-set-map是否继承自collection接口">List, Set, Map是否继承自Collection接口?</a></h2>
<p>List，Set是，Map不是</p>
<h2 id="set里的元素是不能重复的那么用什么方法来区分重复与否呢-是用还是equals-它们有何区别"><a class="header" href="#set里的元素是不能重复的那么用什么方法来区分重复与否呢-是用还是equals-它们有何区别">Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?</a></h2>
<p>Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。equals()是判读两个Set是否相等。</p>
<p>equals()和==方法决定引用值是否指向同一对像，equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。</p>
<h2 id="有50万个int类型的数字现在需要判断一下里面是否存在重复的数字请你简要说一下思路"><a class="header" href="#有50万个int类型的数字现在需要判断一下里面是否存在重复的数字请你简要说一下思路">有50万个int类型的数字，现在需要判断一下里面是否存在重复的数字，请你简要说一下思路。</a></h2>
<ol>
<li>使用C#的List集合自带的去重方法，例如 Distinct()，GroupBy()等</li>
<li>利用 Dictionary 的Key值唯一的特性，HashSet 元素值唯一的特性 进行判断</li>
</ol>
<h2 id="数组有没有length这个方法-string有没有length这个方法"><a class="header" href="#数组有没有length这个方法-string有没有length这个方法">数组有没有length()这个方法? String有没有length()这个方法？</a></h2>
<p>数组没有length()这个方法，有length的属性。String有有length()这个方法。</p>
<h2 id="一个整数list中取出最大数找最大值不能用max方法"><a class="header" href="#一个整数list中取出最大数找最大值不能用max方法">一个整数List中取出最大数（找最大值）。不能用Max方法。</a></h2>
<pre><code class="language-csharp">private static int GetMax(List&lt;int&gt; list)
{
    int max = list[0];
    for (int i = 0; i &lt; list.Count; i++)
    {
        if (list[i]&gt;max)
        {
            max = list[i];
        }
    }
    return max;
}
</code></pre>
<h2 id="利用ienumerable实现斐波那契数列生成"><a class="header" href="#利用ienumerable实现斐波那契数列生成">利用IEnumerable实现斐波那契数列生成?</a></h2>
<pre><code class="language-csharp">IEnumerable&lt;int&gt; GenerateFibonacci(int n)
{
    if (n &gt;= 1) yield return 1;
    int a = 1, b = 0;
    for (int i = 2; i &lt;= n; ++i)
    {
        int t = b;
        b = a;
        a += t;
        yield return a;
    }
}
</code></pre>
<h2 id="请利用-foreach-和-ref-为一个数组中的每个元素加-1"><a class="header" href="#请利用-foreach-和-ref-为一个数组中的每个元素加-1">请利用 foreach 和 ref 为一个数组中的每个元素加 1</a></h2>
<p>注意 foreach 不能用 var ，也不能直接用 int ，需要 ref int ，注意 arr 要转换为 Span 。</p>
<pre><code class="language-csharp">int[] arr = { 1, 2, 3, 4, 5};
Console.WriteLine(string.Join(",", arr)); // 1,2,3,4,5
foreach (ref int v in arr.AsSpan())
{
	v++;
}
Console.WriteLine(string.Join(",", arr)); // 2,3,4,5,6
</code></pre>
<h2 id="能用foreach遍历访问的对象需要实现-接口或声明方法的类型"><a class="header" href="#能用foreach遍历访问的对象需要实现-接口或声明方法的类型">能用foreach遍历访问的对象需要实现 接口或声明方法的类型</a></h2>
<p>答：IEnumerable 、 GetEnumerator。</p>
<h2 id="什么是ienumerable"><a class="header" href="#什么是ienumerable">什么是IEnumerable？</a></h2>
<p>IEnumerable及IEnumerable的泛型版本IEnumerable是一个接口，它只含有一个方法GetEnumerator。Enumerable这个静态类型含有很多扩展方法，其扩展的目标是IEnumerable。</p>
<p>实现了这个接口的类可以使用Foreach关键字进行迭代（迭代的意思是对于一个集合，可以逐一取出元素并遍历之）。实现这个接口必须实现方法GetEnumerator。</p>
<h2 id="ienumerable的缺点有哪些"><a class="header" href="#ienumerable的缺点有哪些">IEnumerable的缺点有哪些？</a></h2>
<p>IEnumerable功能有限，不能插入和删除。</p>
<p>访问IEnumerable只能通过迭代，不能使用索引器。迭代显然是非线程安全的，每次IEnumerable都会生成新的IEnumerator，从而形成多个互相不影响的迭代过程。</p>
<p>在迭代时，只能前进不能后退。新的迭代不会记得之前迭代后值的任何变化。</p>
<h2 id="延迟执行-lazy-loading是什么"><a class="header" href="#延迟执行-lazy-loading是什么">延迟执行 (Lazy Loading)是什么？</a></h2>
<p>大部分LINQ语句是在最终结果的第一个元素被访问的时候（即在foreach中调用MoveNext方法）才真正开始运算的，这个特点称为延迟执行。一般来说，返回另外一个序列（通常为IEnumerable或IQueryable）的操作，使用延迟执行，而返回单一值的运算，使用立即执行。</p>
<p>IEnumerable是延迟执行的，当没有触发执行时，就不会进行任何运算。Select方法不会触发LINQ的执行。一些触发的方式是：foreach循环，ToList，ToArray，ToDictionary方法等</p>
<h2 id="linq可视化工具简单介绍一下"><a class="header" href="#linq可视化工具简单介绍一下">LINQ可视化工具简单介绍一下？</a></h2>
<p>LINQPad工具是一个很好的LINQ查询可视化工具。它由Threading in C#和C# in a Nutshell的作者Albahari编写，完全免费。它的下载地址是http://www.linqpad.net/</p>
<p>进入界面后，LINQPad可以连接到已经存在的数据库（不过就仅限微软的SQL Server系，如果要连接到其他类型的数据库则需要安装插件）。某种程度上可以代替SQL Management Studio，是使用SQL Management Studio作为数据库管理软件的码农的强力工具，可以用于调试和性能优化（通过改善编译后的SQL规模）。</p>
<p>LINQPad支持使用SQL或C#语句（点标记或查询表达式）进行查询。你也可以通过点击橙色圈内的各种不同格式，看到查询表达式的各种不同表达方式：</p>
<ul>
<li>Lambda：查询表达式的Lambda表达式版本，</li>
<li>SQL：由编译器转化成的SQL，通常这是我们最关心的部分，</li>
<li>IL：IL语言</li>
</ul>
<h2 id="linq-to-object和linq-to-sql有何区别"><a class="header" href="#linq-to-object和linq-to-sql有何区别">LINQ to Object和LINQ to SQL有何区别？</a></h2>
<p>LINQ to SQL可以将查询表达式转换为SQL语句，然后在数据库中执行。相比LINQ to Object，则是将查询表达式直接转化为Enumerable的一系列方法，最终在C#内部执行。LINQ to Object的数据源总是实现IEnumerable（所以不如叫做LINQ to IEnumerable），相对的，LINQ to SQL的数据源总是实现IQueryable并使用Queryable的扩展方法。</p>
<p>将查询表达式转换为SQL语句并不保证一定可以成功。</p>
<h2 id="collection和collections的区别"><a class="header" href="#collection和collections的区别">Collection和Collections的区别？</a></h2>
<p>Collection 是集合类的上级接口，Collections 是针对集合类的一个帮助类，它提供一系列静态方法来实现对各种集合的搜索，排序，线程安全化操作。</p>
<h2 id="能用foreach-遍历访问的对象的要求"><a class="header" href="#能用foreach-遍历访问的对象的要求">能用foreach 遍历访问的对象的要求？</a></h2>
<p>需要实现IEnumerable接口或声明GetEnumerator方法的类型。</p>
<h2 id="说出五个集合类"><a class="header" href="#说出五个集合类">说出五个集合类？</a></h2>
<ul>
<li>List：泛型类；</li>
<li>Stack：堆栈，后进先出的访问各个元素</li>
<li>Dictionary&lt;TKey, TValue&gt;：字典类，key是区分大小写；value用于存储对应于key的值</li>
<li>HashSet：此集合类中不能有重复的子元素</li>
<li>SortedList&lt;TKey, TValue&gt;：排序列表，key是排好序的数组。</li>
</ul>
<h2 id="hashmap和hashtable区别"><a class="header" href="#hashmap和hashtable区别">HashMap和Hashtable区别？</a></h2>
<p>在.Net 模仿 java 的过程中抛弃了 HashMap ，所以以后再去面试.Net的时候当别人问你 HashTable 和 HashMap 的区别的时候，请告诉他，C#.Net 中 没有HashMap，与其相似的是 Dictionary。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">特性</th><th style="text-align: left"><code>Hashtable</code> (非泛型)</th><th style="text-align: left"><code>Dictionary&lt;TKey, TValue&gt;</code> (泛型)</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>命名空间</strong></td><td style="text-align: left"><code>System.Collections</code> (旧版)</td><td style="text-align: left"><code>System.Collections.Generic</code> (现代)</td></tr>
<tr><td style="text-align: left"><strong>基类/接口</strong></td><td style="text-align: left">实现 <code>IDictionary</code> 接口</td><td style="text-align: left">实现 <code>IDictionary&lt;TKey, TValue&gt;</code> 泛型接口</td></tr>
<tr><td style="text-align: left"><strong>类型安全</strong></td><td style="text-align: left">存储 <code>object</code>，需装箱拆箱</td><td style="text-align: left">泛型，无需类型转换</td></tr>
<tr><td style="text-align: left"><strong>线程安全</strong></td><td style="text-align: left">是（方法级同步锁）</td><td style="text-align: left">否（需手动同步或使用 <code>ConcurrentDictionary</code>）</td></tr>
<tr><td style="text-align: left"><strong>性能</strong></td><td style="text-align: left">较低（因装箱拆箱）</td><td style="text-align: left">更高（无装箱拆箱）</td></tr>
</tbody></table>
</div>
<p>单线程程序中推荐使用 Dictionary, 有泛型优势, 且读取速度较快, 容量利用更充分。多线程程序中推荐使用 Hashtable, 默认的 Hashtable 允许单线程写入, 多线程读取, 对 Hashtable 进一步调用 Synchronized() 方法可以获得完全线程安全的类型. 而 Dictionary 非线程安全, 必须人为使用 lock 语句进行保护, 效率大减。</p>
<h2 id="简述一下-dictionary泛型的实现以及如何避免碰撞"><a class="header" href="#简述一下-dictionary泛型的实现以及如何避免碰撞">简述一下 Dictionary泛型的实现，以及如何避免碰撞？</a></h2>
<p>实现方式</p>
<ol>
<li>底层数据结构</li>
</ol>
<ul>
<li>哈希桶（Buckets）数组：存储索引，指向条目（Entries）数组中的位置。</li>
<li>条目（Entries）数组：存储实际的键值对，结构为 {hashCode, key, value, next}。
<ul>
<li>next 字段用于处理碰撞（链地址法）。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>关键机制</li>
</ol>
<ul>
<li>哈希函数：对键调用 GetHashCode() 计算哈希值，再通过取模运算确定桶位置。</li>
<li>扩容策略：当元素数量超过 容量 × 负载因子（默认 0.75）时，容量翻倍并重新哈希。</li>
</ul>
<ol start="3">
<li>操作复杂度</li>
</ol>
<ul>
<li>插入/查找/删除：平均 O(1)（理想情况下），最坏 O(n)（全碰撞时）。</li>
</ul>
<p>解决碰撞冲突</p>
<ol>
<li>
<p>链地址法（Separate Chaining）</p>
<ul>
<li>
<p>实现方式：
每个哈希桶指向一个链表（实际用 <code>Entries</code> 数组 + <code>next</code> 索引模拟链表）。
碰撞时，新条目被添加到链表头部（<code>next</code> 指向原桶中的条目）。</p>
</li>
<li>
<p>示例：</p>
<pre><code class="language-csharp">// 假设哈希冲突：keyA 和 keyB 的哈希值均映射到桶 2
entries[0] = {hashA, keyA, valueA, -1}  // 桶 2 指向索引 0
entries[1] = {hashB, keyB, valueB, 0}   // next=0，链接到前一个条目
</code></pre>
</li>
</ul>
</li>
<li>
<p>优化措施</p>
<ul>
<li>快速模运算：用 <code>hashCode &amp; (buckets.Length - 1)</code> 替代取模（要求容量为 2 的幂）。</li>
<li>素数容量：初始容量为素数（如 3, 7, 11），减少哈希聚集（.NET Core 后改用 2 的幂容量）。</li>
<li>自动扩容：减少碰撞概率。</li>
</ul>
</li>
</ol>
<h2 id="数组链表哈希队列栈数据结构特点各自优点和缺点"><a class="header" href="#数组链表哈希队列栈数据结构特点各自优点和缺点">数组、链表、哈希、队列、栈数据结构特点，各自优点和缺点？</a></h2>
<p><strong>数组(Array)：</strong>
优点：查询快，通过索引直接查找；有序添加，添加速度快，允许重复；
缺点：在中间部位添加、删除比较复杂，大小固定，只能存储一种类型的数据；
如果应用需要快速访问数据，很少插入和删除元素，就应该用数组。</p>
<p><strong>链表(LinkedList)：</strong>
优点：有序添加、增删改速度快，对于链表数据结构，增加和删除只要修改元素中的指针就可以了；
缺点：查询慢，如果要访问链表中一个元素，就需要从第一个元素开始查找；
如果应用需要经常插入和删除元素，就应该用链表。</p>
<p><strong>栈(Stack)：</strong>
优点：提供后进先出的存储方式，添加速度快，允许重复；
缺点：只能在一头操作数据，存取其他项很慢；</p>
<p><strong>队列(Queue)：</strong>
优点：提供先进先出的存储方式，添加速度快，允许重复；
缺点：只能在一头添加，另一头获取，存取其他项很慢；</p>
<p><strong>哈希(Hash)：</strong>
特点：散列表，不允许重复；
优点：如果关键字已知则存取速度极快；
缺点：如果不知道关键字则存取很慢，对存储空间使用不充分；</p>

                        </div>
                        <div id="sidetoc">
                            <nav id="pagetoc"></nav>
                        </div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="object-oriented/design-pattern.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="generics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="object-oriented/design-pattern.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="generics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>


    </div>
    </body>
</html>